---
import BaseLayout from "../../layouts/BaseLayout.astro";
import {
  acquisitionIntegration,
  formatDate,
  formatIntegrationSeconds,
  getAllImages,
  getImageAssetUrl,
  getImageById,
  getDetailedAcquisitions,
  getSiteData,
  getSkychartUrl,
  imageExposureSummary,
  imageFocalLengthMm,
  imageSessionCount,
  imageTotalIntegration
} from "../../lib/content";

export async function getStaticPaths() {
  const images = await getAllImages();
  return images.map((image) => ({
    params: { id: image.id }
  }));
}

const { id } = Astro.params;
if (!id) {
  throw new Error("Missing image id");
}

const image = await getImageById(id);
if (!image) {
  return Astro.redirect("/gallery");
}

const { objects, equipment, locations } = await getSiteData();

const location = locations.find((entry) => entry.id === image.location_id);
const objectItems = image.targets
  .map((targetId) => objects.find((entry) => entry.id === targetId))
  .filter((entry) => entry !== undefined);

const scope = equipment.find((entry) => entry.id === image.equipment.scope_id);
const mount = equipment.find((entry) => entry.id === image.equipment.mount_id);
const camera = equipment.find((entry) => entry.id === image.equipment.camera_id);
const filter = image.equipment.filter_id
  ? equipment.find((entry) => entry.id === image.equipment.filter_id)
  : undefined;

const totalIntegration = imageTotalIntegration(image);
const sessionCount = imageSessionCount(image);
const exposureSummary = imageExposureSummary(image);
const detailedAcquisitions = getDetailedAcquisitions(image);
const focalLengthMm = imageFocalLengthMm(image, scope);
const skychartUrl = getSkychartUrl(image);
const locationLat = location?.lat !== undefined ? location.lat.toFixed(4) : undefined;
const locationLon = location?.lon !== undefined ? location.lon.toFixed(4) : undefined;

const scopeAperture = typeof scope?.specs?.aperture_mm === "number" ? scope.specs.aperture_mm : null;
const scopeNativeFocal = typeof scope?.specs?.focal_length_mm === "number" ? scope.specs.focal_length_mm : null;
const scopeFRatioValue =
  typeof scope?.specs?.focal_ratio === "number"
    ? scope.specs.focal_ratio
    : scopeAperture && scopeNativeFocal
      ? scopeNativeFocal / scopeAperture
      : null;
const scopeFRatio = scopeFRatioValue ? `f/${scopeFRatioValue.toFixed(1)}` : null;

const mountTypeRaw = typeof mount?.specs?.mount_type === "string" ? mount.specs.mount_type : null;
const mountType = mountTypeRaw ? mountTypeRaw.replace(/-/g, " ") : null;

const filterTypeRaw = typeof filter?.specs?.filter_type === "string" ? filter.specs.filter_type : null;
const filterType = filterTypeRaw ? filterTypeRaw.replace(/-/g, " ") : null;
const filterSizeInch =
  typeof filter?.specs?.size_inch === "number" || typeof filter?.specs?.size_inch === "string"
    ? `${filter.specs.size_inch}\"`
    : null;

const showCaptureTile = totalIntegration !== null && sessionCount !== null && exposureSummary !== null;
const showCaptureDetails = detailedAcquisitions.length > 0;
const effectiveFRatio = scopeAperture && focalLengthMm ? focalLengthMm / scopeAperture : null;
const isSolarSystem = image.capture_mode === "solar_system";

const totalVideoFrames = detailedAcquisitions.reduce((sum, acquisition) => sum + acquisition.frames, 0);
const uniqueExposurePerFrame = Array.from(new Set(detailedAcquisitions.map((acquisition) => acquisition.exposure_s)));
const exposurePerFrame =
  uniqueExposurePerFrame.length === 1
    ? uniqueExposurePerFrame[0] < 1
      ? `${Math.round(uniqueExposurePerFrame[0] * 1000)} ms`
      : `${uniqueExposurePerFrame[0]} s`
    : "mixed";

const stackedPercentValues = detailedAcquisitions
  .map((acquisition) => acquisition.stacked_percent)
  .filter((value): value is number => typeof value === "number");
const stackedSummary =
  stackedPercentValues.length === 0
    ? null
    : Array.from(new Set(stackedPercentValues)).length === 1
      ? `${stackedPercentValues[0]}% stacked`
      : `${Math.min(...stackedPercentValues)}-${Math.max(...stackedPercentValues)}% stacked`;

const showDeepSkyCaptureTile = !isSolarSystem && showCaptureTile;
const showSolarCaptureTile = isSolarSystem && showCaptureDetails;
---

<BaseLayout
  title={`${image.title} | AstroCaptures`}
  description={image.description ?? image.title}
  image={getImageAssetUrl(image, "web")}
  canonicalPath={`/images/${image.id}`}
>
  <section class="hero">
    <h1>{image.title}</h1>
    <p class="muted">{formatDate(image.date)}</p>
    {image.description && <p>{image.description}</p>}
  </section>

  <section class="image-stage">
    <button
      type="button"
      class="image-view-trigger"
      id="open-image-viewer"
      aria-haspopup="dialog"
      aria-controls="image-viewer-dialog"
      aria-label={`Open full-size viewer for ${image.title}`}
    >
      <img
        src={getImageAssetUrl(image, "web")}
        alt={image.seo?.alt ?? image.title}
        loading="eager"
        fetchpriority="high"
      />
    </button>
    <div class="image-actions">
      <button type="button" class="download-btn" id="open-image-viewer-btn">View full size</button>
      <a class="download-btn" href={getImageAssetUrl(image, "original")} download>Download original JPG</a>
    </div>

    <dl class="meta-grid">
      <div class="meta-tile">
        <dt>Location</dt>
        <dd>{location ? `${location.name}, ${location.country}` : image.location_id}</dd>
        {locationLat && locationLon && <small class="meta-sub">lat: {locationLat}, long: {locationLon}</small>}
        {location?.bortle && <small class="meta-sub">Bortle {location.bortle}</small>}
      </div>
      {showDeepSkyCaptureTile && (
        <div class="meta-tile">
          <dt>Capture</dt>
          <dd>{formatIntegrationSeconds(totalIntegration!)}</dd>
          <small class="meta-sub">
            {sessionCount!} session{sessionCount === 1 ? "" : "s"} 路 {exposureSummary!.value}
          </small>
          {exposureSummary!.secondary && <small class="meta-sub">{exposureSummary!.secondary}</small>}
        </div>
      )}
      {showSolarCaptureTile && (
        <div class="meta-tile">
          <dt>Capture</dt>
          <dd>{totalVideoFrames} video frames</dd>
          <small class="meta-sub">Exposure/frame: {exposurePerFrame}</small>
          {stackedSummary && <small class="meta-sub">{stackedSummary}</small>}
        </div>
      )}
      {focalLengthMm !== null && (
        <div class="meta-tile">
          <dt>Focal length</dt>
          <dd>{`${focalLengthMm} mm`}</dd>
          {effectiveFRatio !== null && <small class="meta-sub">{`f/${effectiveFRatio.toFixed(1)}`}</small>}
        </div>
      )}
    </dl>

    <div class="panel" style="margin-top:0.9rem;">
      <h2>Objects</h2>
      <div class="pill-list" style="margin-top:0.7rem;">
        {objectItems.map((item) => (
          <a class="pill" href={`/objects/${item.slug}`}>{item.title}</a>
        ))}
      </div>
    </div>

    <div class:list={{ "detail-grid": true, "detail-grid-single": !skychartUrl }} style="margin-top:0.9rem;">
      {skychartUrl && (
        <section class="panel">
          <h2>Sky Chart</h2>
          <img
            class="skychart-img"
            src={skychartUrl}
            alt={image.skychart?.caption ?? `Sky chart for ${image.title}`}
            loading="lazy"
          />
        </section>
      )}

      <aside class="panel meta-list">
        <div>
          <h2>Equipment</h2>
          <dd class="equipment-list">
            <div>
              <span class="equip-label">Scope</span>
              <span>{scope ? `${scope.brand} ${scope.model}` : image.equipment.scope_id}</span>
              {(scopeAperture || scopeNativeFocal || scopeFRatio) && (
                <small class="equipment-spec">
                  {scopeAperture && `${scopeAperture}mm`}
                  {scopeAperture && scopeNativeFocal && " 路 "}
                  {scopeNativeFocal && `${scopeNativeFocal}mm`}
                  {(scopeAperture || scopeNativeFocal) && scopeFRatio && " 路 "}
                  {scopeFRatio && scopeFRatio}
                </small>
              )}
            </div>
            <div>
              <span class="equip-label">Mount</span>
              <span>{mount ? `${mount.brand} ${mount.model}` : image.equipment.mount_id}</span>
              {mountType && <small class="equipment-spec">{mountType}</small>}
            </div>
            <div>
              <span class="equip-label">Camera</span>
              <span>{camera ? `${camera.brand} ${camera.model}` : image.equipment.camera_id}</span>
            </div>
            {filter && (
              <div>
                <span class="equip-label">Filter</span>
                <span>{`${filter.brand} ${filter.model}`}</span>
                {(filterType || filterSizeInch) && (
                  <small class="equipment-spec">
                    {filterType}
                    {filterType && filterSizeInch && " 路 "}
                    {filterSizeInch}
                  </small>
                )}
              </div>
            )}
          </dd>
        </div>
      </aside>
    </div>

    {showCaptureDetails && (
      <details class="panel capture-details" style="margin-top:0.9rem;">
        <summary>Capture details</summary>
        <table>
          <thead>
            {isSolarSystem ? (
              <tr>
                <th>Date</th>
                <th>Video frames</th>
                <th>Exposure/frame</th>
                <th>Stacked</th>
              </tr>
            ) : (
              <tr>
                <th>Date</th>
                <th>Frames</th>
                <th>Exposure</th>
                <th>Integration</th>
              </tr>
            )}
          </thead>
          <tbody>
            {detailedAcquisitions.map((acquisition) => (
              <tr>
                <td>{formatDate(acquisition.date)}</td>
                <td>{acquisition.frames}</td>
                <td>{acquisition.exposure_s < 1 ? `${Math.round(acquisition.exposure_s * 1000)} ms` : `${acquisition.exposure_s}s`}</td>
                {isSolarSystem ? (
                  <td>{typeof acquisition.stacked_percent === "number" ? `${acquisition.stacked_percent}%` : "-"}</td>
                ) : (
                  <td>{formatIntegrationSeconds(acquisitionIntegration(acquisition))}</td>
                )}
              </tr>
            ))}
          </tbody>
        </table>
      </details>
    )}

    <dialog class="image-viewer" id="image-viewer-dialog" aria-label={`Image viewer for ${image.title}`}>
      <div class="image-viewer-body">
        <div class="image-viewer-viewport" id="image-viewer-viewport">
          <div class="viewer-overlay" role="group" aria-label="Image viewer controls">
            <button type="button" class="viewer-control-btn" id="close-viewer-btn" aria-label="Close image viewer">
              Close
            </button>
            <button type="button" class="viewer-control-btn" id="zoom-out-btn" aria-label="Zoom out">-</button>
            <button type="button" class="viewer-control-btn" id="zoom-in-btn" aria-label="Zoom in">+</button>
            <button type="button" class="viewer-control-btn" id="fit-image-btn">Fit</button>
            <button type="button" class="viewer-control-btn" id="fullsize-image-btn">100%</button>
            <button type="button" class="viewer-control-btn" id="double-size-image-btn">200%</button>
            <span class="viewer-zoom-label" id="zoom-label">100%</span>
          </div>
          <div class="image-viewer-canvas" id="image-viewer-canvas">
            <img
              id="image-viewer-image"
              src={getImageAssetUrl(image, "web")}
              data-web-src={getImageAssetUrl(image, "web")}
              data-original-src={getImageAssetUrl(image, "original")}
              alt={image.seo?.alt ?? image.title}
              draggable="false"
            />
          </div>
        </div>
      </div>
    </dialog>
  </section>
</BaseLayout>

<script is:inline>
  const openImageViewer = document.getElementById("open-image-viewer");
  const openImageViewerButton = document.getElementById("open-image-viewer-btn");
  const viewerDialog = document.getElementById("image-viewer-dialog");
  const viewerViewport = document.getElementById("image-viewer-viewport");
  const viewerCanvas = document.getElementById("image-viewer-canvas");
  const viewerImage = document.getElementById("image-viewer-image");
  const closeViewerButton = document.getElementById("close-viewer-btn");
  const zoomOutButton = document.getElementById("zoom-out-btn");
  const zoomInButton = document.getElementById("zoom-in-btn");
  const fitButton = document.getElementById("fit-image-btn");
  const fullsizeButton = document.getElementById("fullsize-image-btn");
  const doubleSizeButton = document.getElementById("double-size-image-btn");
  const zoomLabel = document.getElementById("zoom-label");

  if (
    openImageViewer instanceof HTMLElement &&
    openImageViewerButton instanceof HTMLElement &&
    viewerDialog instanceof HTMLDialogElement &&
    viewerImage instanceof HTMLImageElement &&
    viewerViewport instanceof HTMLElement &&
    viewerCanvas instanceof HTMLElement &&
    closeViewerButton instanceof HTMLButtonElement &&
    zoomOutButton instanceof HTMLButtonElement &&
    zoomInButton instanceof HTMLButtonElement &&
    fitButton instanceof HTMLButtonElement &&
    fullsizeButton instanceof HTMLButtonElement &&
    doubleSizeButton instanceof HTMLButtonElement &&
    zoomLabel instanceof HTMLElement
  ) {
    let lastTrigger = null;
    let loadedOriginal = false;
    const supportsDialog = typeof viewerDialog.showModal === "function";
    const pointerMap = new Map();

    let fitScale = 1;
    let nativeScale = 1;
    let maxScale = 1;
    let scale = 1;
    let tx = 0;
    let ty = 0;

    let dragState = null;
    let pinchState = null;

    const roundZoomPercent = (value) => `${Math.round(value * 100)}%`;

    const clampPan = () => {
      const viewportWidth = viewerViewport.clientWidth;
      const viewportHeight = viewerViewport.clientHeight;
      const imageWidth = viewerImage.naturalWidth * scale;
      const imageHeight = viewerImage.naturalHeight * scale;

      const maxX = Math.max(0, (imageWidth - viewportWidth) / 2);
      const maxY = Math.max(0, (imageHeight - viewportHeight) / 2);

      tx = Math.min(maxX, Math.max(-maxX, tx));
      ty = Math.min(maxY, Math.max(-maxY, ty));
    };

    const render = () => {
      viewerCanvas.style.transform = `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(${scale})`;
      const relativeZoom = nativeScale > 0 ? scale / nativeScale : scale;
      zoomLabel.textContent = roundZoomPercent(relativeZoom);

      const atMin = scale <= fitScale + 0.001;
      const atNative = Math.abs(scale - nativeScale) <= 0.001;
      const atMax = scale >= maxScale - 0.001;

      zoomOutButton.disabled = atMin;
      zoomInButton.disabled = atMax;
      fitButton.disabled = atMin;
      fullsizeButton.disabled = atNative;
      doubleSizeButton.disabled = atMax;

      viewerViewport.classList.toggle("is-pannable", !atMin);
      if (atMin) {
        viewerViewport.classList.remove("is-panning");
      }
    };

    const clampScale = (nextScale) => Math.min(maxScale, Math.max(fitScale, nextScale));

    const setScale = (nextScale, anchorClientX, anchorClientY) => {
      const previousScale = scale;
      const targetScale = clampScale(nextScale);
      if (Math.abs(targetScale - previousScale) < 0.0001) {
        return;
      }

      if (typeof anchorClientX === "number" && typeof anchorClientY === "number") {
        const rect = viewerViewport.getBoundingClientRect();
        const localX = anchorClientX - (rect.left + rect.width / 2);
        const localY = anchorClientY - (rect.top + rect.height / 2);

        const imageX = (localX - tx) / previousScale;
        const imageY = (localY - ty) / previousScale;

        scale = targetScale;
        tx = localX - imageX * scale;
        ty = localY - imageY * scale;
      } else {
        scale = targetScale;
      }

      clampPan();
      render();
    };

    const fitToWindow = () => {
      scale = fitScale;
      tx = 0;
      ty = 0;
      render();
    };

    const setFullSize = () => {
      scale = nativeScale;
      tx = 0;
      ty = 0;
      clampPan();
      render();
    };

    const setDoubleSize = () => {
      scale = maxScale;
      tx = 0;
      ty = 0;
      clampPan();
      render();
    };

    const refreshFitScale = (resetZoom) => {
      const viewportWidth = viewerViewport.clientWidth;
      const viewportHeight = viewerViewport.clientHeight;
      const naturalWidth = viewerImage.naturalWidth;
      const naturalHeight = viewerImage.naturalHeight;

      if (!viewportWidth || !viewportHeight || !naturalWidth || !naturalHeight) {
        return;
      }

      nativeScale = 1 / Math.max(1, window.devicePixelRatio || 1);
      maxScale = Math.max(nativeScale, nativeScale * 2);
      fitScale = Math.min(nativeScale, viewportWidth / naturalWidth, viewportHeight / naturalHeight);

      if (resetZoom) {
        scale = fitScale;
        tx = 0;
        ty = 0;
      } else {
        scale = clampScale(scale);
        clampPan();
      }

      render();
    };

    const ensureOriginalLoaded = (onReady) => {
      if (loadedOriginal) {
        onReady();
        return;
      }

      const originalSource = viewerImage.dataset.originalSrc;
      const webSource = viewerImage.dataset.webSrc;

      if (!originalSource) {
        onReady();
        return;
      }

      zoomLabel.textContent = "Loading...";

      viewerImage.addEventListener(
        "load",
        () => {
          loadedOriginal = viewerImage.src.includes(originalSource);
          onReady();
        },
        { once: true }
      );

      viewerImage.addEventListener(
        "error",
        () => {
          if (webSource) {
            viewerImage.src = webSource;
          }
          onReady();
        },
        { once: true }
      );

      viewerImage.src = originalSource;
    };

    const openFallback = () => {
      const webSource = viewerImage.dataset.webSrc;
      if (webSource) {
        window.open(webSource, "_blank", "noopener,noreferrer");
      }
    };

    const openViewer = (trigger) => {
      if (!supportsDialog) {
        openFallback();
        return;
      }

      lastTrigger = trigger;
      viewerDialog.showModal();
      ensureOriginalLoaded(() => refreshFitScale(true));
    };

    const mobileViewerMedia = window.matchMedia("(max-width: 560px)");

    openImageViewer.addEventListener("click", () => {
      if (mobileViewerMedia.matches) {
        return;
      }
      openViewer(openImageViewer);
    });
    openImageViewerButton.addEventListener("click", () => openViewer(openImageViewerButton));

    viewerDialog.addEventListener("close", () => {
      pointerMap.clear();
      dragState = null;
      pinchState = null;
      viewerViewport.classList.remove("is-panning");

      if (lastTrigger instanceof HTMLElement) {
        lastTrigger.focus();
      }
    });

    viewerDialog.addEventListener("cancel", (event) => {
      event.preventDefault();
      viewerDialog.close();
    });

    viewerDialog.addEventListener("click", (event) => {
      const rect = viewerDialog.getBoundingClientRect();
      const isInDialog =
        event.clientX >= rect.left &&
        event.clientX <= rect.right &&
        event.clientY >= rect.top &&
        event.clientY <= rect.bottom;

      if (!isInDialog) {
        viewerDialog.close();
      }
    });

    viewerViewport.addEventListener("wheel", (event) => {
      if (event.target instanceof Element && event.target.closest(".viewer-overlay")) {
        return;
      }
      event.preventDefault();
      const zoomFactor = event.deltaY < 0 ? 1.1 : 1 / 1.1;
      setScale(scale * zoomFactor, event.clientX, event.clientY);
    });

    closeViewerButton.addEventListener("click", () => {
      viewerDialog.close();
    });

    zoomOutButton.addEventListener("click", () => {
      setScale(scale / 1.2);
    });

    zoomInButton.addEventListener("click", () => {
      setScale(scale * 1.2);
    });

    fitButton.addEventListener("click", () => {
      fitToWindow();
    });

    fullsizeButton.addEventListener("click", () => {
      setFullSize();
    });

    doubleSizeButton.addEventListener("click", () => {
      setDoubleSize();
    });

    viewerViewport.addEventListener("pointerdown", (event) => {
      if (event.target instanceof Element && event.target.closest(".viewer-overlay")) {
        return;
      }
      viewerViewport.setPointerCapture(event.pointerId);
      pointerMap.set(event.pointerId, { x: event.clientX, y: event.clientY });

      if (pointerMap.size === 1 && scale > fitScale + 0.001) {
        dragState = {
          pointerId: event.pointerId,
          startX: event.clientX,
          startY: event.clientY,
          startTx: tx,
          startTy: ty
        };
        viewerViewport.classList.add("is-panning");
      }

      if (pointerMap.size === 2) {
        const points = Array.from(pointerMap.values());
        const dx = points[0].x - points[1].x;
        const dy = points[0].y - points[1].y;

        pinchState = {
          startDistance: Math.hypot(dx, dy),
          startScale: scale
        };
        dragState = null;
        viewerViewport.classList.remove("is-panning");
      }
    });

    viewerViewport.addEventListener("pointermove", (event) => {
      if (!pointerMap.has(event.pointerId)) {
        return;
      }

      pointerMap.set(event.pointerId, { x: event.clientX, y: event.clientY });

      if (pointerMap.size === 2 && pinchState) {
        const points = Array.from(pointerMap.values());
        const dx = points[0].x - points[1].x;
        const dy = points[0].y - points[1].y;
        const distance = Math.hypot(dx, dy);
        const midpointX = (points[0].x + points[1].x) / 2;
        const midpointY = (points[0].y + points[1].y) / 2;

        if (pinchState.startDistance > 0) {
          const pinchScale = pinchState.startScale * (distance / pinchState.startDistance);
          setScale(pinchScale, midpointX, midpointY);
        }
        return;
      }

      if (dragState && dragState.pointerId === event.pointerId) {
        tx = dragState.startTx + (event.clientX - dragState.startX);
        ty = dragState.startTy + (event.clientY - dragState.startY);
        clampPan();
        render();
      }
    });

    const endPointer = (event) => {
      pointerMap.delete(event.pointerId);

      if (dragState && dragState.pointerId === event.pointerId) {
        dragState = null;
        viewerViewport.classList.remove("is-panning");
      }

      if (pointerMap.size < 2) {
        pinchState = null;
      }
    };

    viewerViewport.addEventListener("pointerup", endPointer);
    viewerViewport.addEventListener("pointercancel", endPointer);

    window.addEventListener("resize", () => {
      if (viewerDialog.open) {
        refreshFitScale(false);
      }
    });

    refreshFitScale(true);
  }
</script>
